// LoadRelated{{.PropertyName}} is a helper function to load related {{.PropertyName}} entities
func (repo {{.ThisEntity}}Repository) LoadRelated{{.PropertyName}}(ctx context.Context, entities []{{.ThisEntity}}) error {
	var (
		placeholder string
		values  []interface{}
		indices map[{{.ThisType}}]{{.ThisEntity}}
	)

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		break
	}

	c := 1
	for i, entity := range entities {
		placeholder += "$" + strconv.Itoa(c) + ","
		indices[entity.ID] = entity
		values = append(values, i)
		c++
	}
	placeholder = strings.TrimRight(placeholder, ",")

	{{if .Full}}
	rows, err := repo.db.Query(`
		SELECT j.{{.ThisID}}, {{.SQLFields}} FROM {{.ThatTable}} t 
		INNER JOIN {{.JoinTable}} j ON t.id = j.{{.ThatID}}
		WHERE j.{{.ThisID}} IN (`+placeholder+`)
	`, values...)
	if err != nil {
		return err
	}
	{{else}}
	rows, err := repo.db.Query("SELECT {{.ThisID}}, {{.ThatID}} FROM {{.JoinTable}} WHERE {{.ThisID}} IN ("+placeholder+")", values...)
	if err != nil {
		return err
	}
	{{end}}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		break
	}

	for rows.Next() {
		var (
			entity {{.ThisEntity}}
			thisID {{.ThisType}}
			{{if .Full -}}
			thatEntity {{.ThatEntity}}
			{{- else -}}
			thatID {{.ThatType}}
			{{- end -}}
		)
		{{if .Full}}
		err = rows.Scan(&thisID, {{.StructFields}})
		{{- else -}}
		err = rows.Scan(&thisID, &thatID)
		{{end}}
		if err != nil {
			return err
		}
		entity = indices[thisID]
		{{if .Full}}
		entity.{{.PropertyName}} = append(entity.{{.PropertyName}}, &thatEntity)
		{{else}}
		entity.{{.PropertyName}} = append(entity.{{.PropertyName}}, thatID)
		{{end}}
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			break
		}
	}

	return nil
}